<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(Core)\UncommonSense.CBreeze.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="UncommonSense.CBreeze.Core" #>
<#@ output extension=".cs" #>
<#
	// FIXME: Should we support ChildNodes for MenuSuiteNodes?

	var types = AppDomain
		.CurrentDomain
		.GetAssemblies()
		.SelectMany(a => a.GetTypes())
		.Where(t => typeof(MenuSuiteNode).IsAssignableFrom(t))
		.Where(t => typeof(MenuSuiteNode) != t);

	var ignoredProperties = new List<string>() {
		"Node",
		"WithAValue",
		"ChildNodes",
		"ParentNode",
		"Item",
		"CaptionML",
		"AccessByPermission",
		"ApplicationArea",
		"RunObjectType",
		"RunObjectID"
	};

	var mandatoryProperties = new List<string>() {
		"DepartmentCategory",
		"RunObjectType",
		"RunObjectID"
	};

	var rangeMin = new Dictionary<string, string>() {
		{ "Image", "0" }
	};

	var rangeMax = new Dictionary<string, string>() {
		{ "Image", "15" }
	};
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using UncommonSense.CBreeze.Core;
using System.Management.Automation;

// FIXME: For item nodes, allow AccessByPermission to be set directly, e.g. using New-CBreezeAccessByPermission

namespace UncommonSense.CBreeze.Automation 
{
<# foreach(var @type in types) { 
	var propertiesClass = @type.GetProperty("Properties").PropertyType;
	var cmdletNoun = @type.Name.Replace("Node", "MenuSuiteNode");
	var variableName = Char.ToLowerInvariant(@type.Name[0]) + @type.Name.Substring(1);

	var allProperties = propertiesClass.GetProperties();
	var relevantProperties = allProperties
		.Where(p => !ignoredProperties.Contains(p.Name))
		.Select(p => new {
			Name = p.Name,
			Type = p.PropertyType,
			Assignment = p.PropertyType == typeof(bool?) ? $"{variableName}.Properties.{p.Name} = NullableBooleanFromSwitch(nameof({p.Name}));" : $"{variableName}.Properties.{p.Name} = {p.Name};",
			RangeMin = rangeMin.ContainsKey(p.Name) ? rangeMin[p.Name] : "",
			RangeMax = rangeMax.ContainsKey(p.Name) ? rangeMax[p.Name] : "",
			Mandatory = mandatoryProperties.Contains(p.Name),
			RelativePosition = 0
		}).ToList();

	if (allProperties.Any(p => p.Name == "CaptionML")) 
	{
		relevantProperties.Add(new {
			Name = "CaptionML",
			Type = typeof(Hashtable),
			Assignment = $"{variableName}.Properties.CaptionML.Set(CaptionML);",
			RangeMin = "",
			RangeMax = "",
			Mandatory = true,
			RelativePosition = 1
		});
	};

	if (allProperties.Any(p => p.Name == "AccessByPermission"))
    {
		relevantProperties.Add(new {
			Name = "AccessByPermission",
			// Cannot use Type= typeof(AccessByPermission) in pre-2015 code...
			Type = AppDomain.CurrentDomain.GetAssemblies().SelectMany(a=>a.GetTypes()).Single(t => t.FullName == "UncommonSense.CBreeze.Core.AccessByPermission"),
			Assignment = $"{variableName}.Properties.AccessByPermission.Set(AccessByPermission);",
			RangeMin = "",
			RangeMax = "",
			Mandatory = false,
			RelativePosition = 0
		});
	};

	if (allProperties.Any(p => p.Name == "ApplicationArea"))
    {
		relevantProperties.Add(new {
			Name = "ApplicationArea",
			Type = typeof(string[]),
			Assignment = $"{variableName}.Properties.ApplicationArea.Set(ApplicationArea);",
			RangeMin = "",
			RangeMax = "",
			Mandatory = false,
			RelativePosition = 0
		});
	}

	if (allProperties.Any(p => p.Name == "RunObjectType"))
	{
		relevantProperties.Add(new {
			Name = "RunObjectType",
			Type = typeof(MenuItemRunObjectType?),
			Assignment = $"{variableName}.Properties.RunObjectType = RunObjectType;",
			RangeMin = "",
			RangeMax = "",
			Mandatory = true,
			RelativePosition = 2
		});
	}

	if (allProperties.Any(p => p.Name == "RunObjectID"))
	{
		relevantProperties.Add(new {
			Name = "RunObjectID",
			Type = typeof(int?),
			Assignment = $"{variableName}.Properties.RunObjectID = RunObjectID;",
			RangeMin = "1",
			RangeMax = "int.MaxValue",
			Mandatory = true,
			RelativePosition = 3
		});
	}
#>
	[Cmdlet(VerbsCommon.New, "CBreeze<#= cmdletNoun #>", DefaultParameterSetName="NewWithoutID")]
	[OutputType(typeof(<#= type.Name#>))]
	[Alias("<#= type.Name #>")]
	public class NewCBreeze<#= cmdletNoun #> : NewItemWithIDCmdlet<<#= @type.Name #>, Guid, MenuSuite>
	{
		protected override IEnumerable<<#= type.Name #>> CreateItems() 
		{
			var <#= variableName #> = new <#= type.Name #>(ID);	
<# foreach(var property in relevantProperties) { #>
			<#= property.Assignment #>
<# } #>
			yield return <#= variableName #>;
		}

		protected override void AddItemToInputObject(<#= @type.Name #> item, MenuSuite inputObject)
		{
            if (!inputObject.Nodes.Any())
            {
                var deltaNode = inputObject.Nodes.Add(new DeltaNode(Guid.NewGuid()));
                deltaNode.Properties.NextNodeID = item.ID;
            }

            inputObject.Nodes.Add(item);
		}

<# foreach(var property in relevantProperties) { #>
<# 
	var parameterAttributes = new List<string>();

	if (property.RelativePosition == 0) 
	{
		var parameterArguments = new List<string>();
		if (property.Mandatory) 
			{ parameterArguments.Add("Mandatory=true"); }
		parameterAttributes.Add($"[Parameter({ string.Join(", ", parameterArguments) })]");
	} 
	else
	{
		foreach(var parameterSetName in new string[] {"NewWithoutID", "NewWithID", "AddWithoutID", "AddWithID"})
		{
			var propertyOffset = parameterSetName.EndsWith("WithID") ? 1 : 0;
			var parameterArguments = new List<string>();
			if (property.Mandatory)
				{ parameterArguments.Add("Mandatory = true"); }
			parameterArguments.Add($"Position = { propertyOffset + property.RelativePosition}");
			parameterArguments.Add($"ParameterSetName = ParameterSetNames.{parameterSetName}");
	
			parameterAttributes.Add($"[Parameter({ string.Join(", ", parameterArguments) })]");
		}
	}

	foreach(var parameterAttribute in parameterAttributes) { #>
		<#= parameterAttribute #>
<# } #>
<# if (property.RangeMin != "" && property.RangeMax != "") { #>		[ValidateRange(<#= property.RangeMin #>, <#= property.RangeMax #>)] 
<# } #>
		public <#= GetFullTypeName(property.Type) #> <#= property.Name #> 
		{
			get; set;
		}

<# } #>
	}

<# } #>
}

<#+
	static string GetFullTypeName(Type t)
	{
		if (!t.IsGenericType)
			return t.Name;

		if (t == typeof(bool?))
			return "SwitchParameter";

		var stringBuilder = new StringBuilder();

		stringBuilder.Append(t.Name.Substring(0, t.Name.LastIndexOf("`")));
		stringBuilder.Append("<");
		stringBuilder.Append(string.Join(",", t.GetGenericArguments().Select(a => GetFullTypeName(a))));
		stringBuilder.Append(">");

		return stringBuilder.ToString();
	}
#>