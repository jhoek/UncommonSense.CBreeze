<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(Core)\UncommonSense.CBreeze.Core.dll" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="UncommonSense.CBreeze.Core" #>
<#@ output extension=".cs" #>
<#
	var types = AppDomain
		.CurrentDomain
		.GetAssemblies()
		.SelectMany(a => a.GetTypes())
		.Where(t => typeof(Variable).IsAssignableFrom(t))
		.Where(t => typeof(Variable) != t);

	var skipProperties = new List<string>() {
		"ID",
		"Name",
		"Container"
		//"Values",
	};

	var mandatoryProperties = new Dictionary<string, string[]> () {
		{"SubType", new[] { "DotNetVariable", "AutomationVariable", "OcxVariable", "RecordVariable", "PageVariable", "ReportVariable", "CodeunitVariable", "QueryVariable", "TestPageVariable", "XmlPortVariable"  }},
        {"Values", new[] { "TextConstant" }}
	};

	var positionalProperties = new List<string>() { "SubType", "DataLength", "OptionString", "Values" };
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Management.Automation;
using UncommonSense.CBreeze.Core;
using System.Collections;
using System.Collections.Generic;

namespace UncommonSense.CBreeze.Automation 
{
<# foreach(var @type in types) { 
	var variableName = Char.ToLowerInvariant(@type.Name[0]) + @type.Name.Substring(1);
	var allProperties = @type.GetProperties();
	var relevantProperties = allProperties
		.Where(p => !skipProperties.Contains(p.Name))
		.Where(p => p.CanWrite || p.Name == "SubType" || p.Name == "DataLength")
		.Select(p => new {
			Name = p.Name,
			FullType = p.Name != "Values" ? GetFullTypeName(p.PropertyType) : "Hashtable",
			Mandatory = mandatoryProperties.ContainsKey(p.Name) ? mandatoryProperties[p.Name].Contains(@type.Name) : false,
			Assignment = $"{variableName}.{GetAssignment(p)};"
		});
	var hasSubType = allProperties.Any(p => p.Name == "SubType");
	var hasDataLength = allProperties.Any(p => p.Name == "DataLength");
#>
	[Cmdlet(VerbsCommon.New, "CBreeze<#=@type.Name#>", DefaultParameterSetName="NewWithoutID")]
	[OutputType(typeof(<#= @type.Name #>))]
	[Alias("<#= @type.Name #>", "Add-CBreeze<#=@type.Name#>")]
	public class NewBreeze<#=@type.Name#> : NewItemWithIDAndNameCmdlet<<#=type.Name#>, int, PSObject>
	{
		protected override IEnumerable<<#=@type.Name#>> CreateItems()
		{
<# var arguments = new List<string>();
arguments.Add("ID");
arguments.Add("Name");
if (hasSubType) { arguments.Add("SubType"); } 
if (hasDataLength) { arguments.Add("DataLength"); }
#>
			var <#= variableName #> = new <#= @type.Name #>(<#= string.Join(", ", arguments)#>);
<# foreach(var property in relevantProperties.Where(p => p.Name != "SubType").Where(p => p.Name != "DataLength")) { #>
			<#= property.Assignment #>
<# } #>
			yield return <#= variableName #>;
		}

		protected override void AddItemToInputObject(<#=@type.Name#> item, PSObject inputObject)
		{
			inputObject.GetVariables().Add(item);
		}

<# foreach(var property in relevantProperties) { 
	if (!positionalProperties.Contains(property.Name))
	{
		arguments = new List<string>();	
		if (property.Mandatory) { arguments.Add("Mandatory=true"); } #>
		[Parameter(<#= string.Join(", ", arguments) #>)]
<#	}
	else
	{
		foreach(var parameterSetName in new string[] { "NewWithoutID", "NewWithID", "AddWithoutID", "AddWithID"})
		{
			var position = parameterSetName.EndsWith("WithID") ? 3 : 2;
			arguments = new List<string>();
			if (property.Mandatory) { arguments.Add("Mandatory=true"); } 
			arguments.Add($"Position={position}");
			arguments.Add($"ParameterSetName=\"{parameterSetName}\""); #>
		[Parameter(<#= string.Join(", ", arguments) #>)]
<#		}
	}
#>
		public <#= property.FullType #> <#= property.Name #> { get; set; } 

<# } #>
	}

<# } #>
}

<#+
	static string GetFullTypeName(Type t)
	{
		if (t == typeof(bool?))
			return "SwitchParameter";

		if (t == typeof(bool))
			return "SwitchParameter";

		if (!t.IsGenericType)
			return t.Name;

		var stringBuilder = new StringBuilder();

		stringBuilder.Append(t.Name.Substring(0, t.Name.LastIndexOf("`")));
		stringBuilder.Append("<");
		stringBuilder.Append(string.Join(",", t.GetGenericArguments().Select(a => GetFullTypeName(a))));
		stringBuilder.Append(">");

		return stringBuilder.ToString();
	}

	static string GetAssignment(PropertyInfo property)
	{
		switch(property)
		{
			case PropertyInfo p when p.Name == "Values": return $"{p.Name}.Set({p.Name})";
			case PropertyInfo p when p.PropertyType == typeof(bool?): return $"{p.Name} = NullableBooleanFromSwitch(nameof({p.Name}))";
			default: return $"{property.Name} = {property.Name}";
        }
	}
#>